#!/usr/bin/gjs

imports.searchPath.unshift('../');
imports.searchPath.unshift('../js');
imports.searchPath.unshift('.');

const GLib = imports.gi.GLib;
const Gio = imports.gi.Gio;

const ANSI_ESC = String.fromCharCode(0x1B);
const ANSI_CSI = ANSI_ESC + '[';
const ANSI_CLOSE = ANSI_CSI + "0m";
const ANSI_BOLD_RED = ANSI_CSI + "1;31m";
const ANSI_RED = ANSI_CSI + "31m";
const ANSI_GREEN = ANSI_CSI + "32m";
const ANSI_BOLD_BLUE = ANSI_CSI + "1;34m";
let TIME_RESOLUTION = 4;
const DEFAULT_TIME_RESOLUTION = 6;
const JS_EXTENSION = '.js';

if (ARGV.length < 1) {
    throw("Usage: run_gjs_tests <test folder>...");
} 

// Import JsUnit
if (!('assertEquals' in this)) 
    imports.lang.copyPublicProperties(imports.jsUnit, this);

//Import Jenkins plugin
if (!('outputJenkinsResults' in this))
    imports.lang.copyPublicProperties(imports.jenkinsTestPlugin, this);

//Add some boilerplate that gnome-shell depends on
window.C_=function(type,text){
 return text;
}
window._=window.C_;
window.global={};

_printColorized = function(color, text){
    print(color + text + ANSI_CLOSE);
}

_printError = function(error){
    const SYNTAX_ERROR = '[object Error]';
    _printColorized(ANSI_RED, " " + error.message);


    if(error.stackTrace){
        let stackTrace = error.stackTrace.split('\n');
        stackTrace.forEach(function(line) {
            if(line.length > 0){
                let prefix = ' --';
                if (error.type == SYNTAX_ERROR)
                    prefix += '> ';

                _printColorized(ANSI_RED, prefix + line);
            }
        });
    }
}

_getTime = function(){
    var time = new GLib.TimeVal();
    GLib.get_current_time(time);
    
    return time.tv_sec + time.tv_usec / Math.pow(10, DEFAULT_TIME_RESOLUTION);
}

_executeTest = function(testFile, test) {
    let result = { "name": test };
    _printColorized(ANSI_BOLD_BLUE, "Running: " + test);
    if(testFile.setUp){
        testFile.setUp();
    }
    let startTime = _getTime();
    try {
        testFile[test]();
    } catch(e) {
        _printColorized(ANSI_BOLD_RED, " ERROR! >>>>> " + test + " <<<<<");

        result.error = { 'type': Object.prototype.toString.apply(e), 
                         'message': e.message || e.jsUnitMessage,
                         'stackTrace':  e.stack || e.stackTrace };
        _printError(result.error);

        print();
    } finally {
        if(testFile.tearDown){
            testFile.tearDown();
        }
    }

    result.time = _getTime() - startTime;
    return result;
}

_executeTestsForFile = function(file){
    eval('let testFile = imports' + file.replace(/\//g, '.'));

    let results = new Array();
    Object.keys(testFile).forEach(function(key){
        if(key.indexOf('test') == 0) {
            results.push(_executeTest(testFile, key));
        }
    });

    return results;

}

_getFilesToTest = function(testDirectory){
    let filesToTest=[];
    let fileEnumerator = testDirectory.enumerate_children("*", Gio.FileQueryInfoFlags.NONE, null);

    let nextFile = fileEnumerator.next_file(null);
    while(nextFile){
        let fileType = nextFile.get_file_type();
        if (fileType == Gio.FileType.DIRECTORY) {
            filesToTest = filesToTest.concat(_getFilesToTest(Gio.file_new_for_path(testDirectory.get_path() + '/' +  nextFile.get_name())));
        } else {
            let filename = nextFile.get_name();
            if(filename.indexOf(JS_EXTENSION, filename.length - JS_EXTENSION.length) !== -1){
                let fixedFilename = testDirectory.get_path() + "/" + nextFile.get_name().substring(0, filename.length - JS_EXTENSION.length);
                filesToTest.push(fixedFilename);
            }
        }
        nextFile = fileEnumerator.next_file(null);
    }
    return filesToTest;

}

_executeAllTests = function(filesToTest) {
    let results = Array();
    filesToTest.forEach(function(file){
        let dirName = '-shell/'
        filePath =  file.substring(file.indexOf(dirName) + dirName.length - 1, file.length);
        print("Testing: " + file);
        results = results.concat(_executeTestsForFile(filePath));
    });
    return results;
}

_getTotalsFromResults = function(results) {
    let testsRunCount = 0;
    let testsFailedCount = 0;
    let testsPassedCount = 0;

    results.forEach(function(result) {
    if ('error' in result) {
            testsFailedCount++;
        }    
        testsRunCount++;
    });

    testsPassedCount = testsRunCount - testsFailedCount;
    return { 'testsRunCount': testsRunCount,
             'testsFailedCount': testsFailedCount,
             'testsPassedCount': testsPassedCount }
}

_displayResults = function(aggregateResults) {
    _printColorized(ANSI_BOLD_BLUE, Array(50).join("-"));
    _printColorized(ANSI_BOLD_BLUE, totalsString);
    _printColorized(ANSI_BOLD_BLUE, "\nExporting Jenkins results");
}

let testDirectory = Gio.file_new_for_path(ARGV[0]);
let filesToTest = _getFilesToTest(testDirectory);
let results = _executeAllTests(filesToTest);
let totals = _getTotalsFromResults(results);


let totalsString = "Ran " + totals.testsRunCount + " tests (" + totals.testsPassedCount + " Passed, " + totals.testsFailedCount + " Failed)";
let aggregateResults = { 'results': results,
                         'name': 'eos-testrunner',
                         'tests': totals.testsRunCount, 
                         'errors': totals.testsFailedCount, 
                         'failures': 0, 
                         'skip': 0 };

_displayResults(aggregateResults);

outputJenkinsResults('jenkins.xml', aggregateResults);

if (totals.testsFailedCount > 0){
    throw ANSI_BOLD_RED + "Test(s) did not complete successfully" + ANSI_CLOSE;
}
